This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
postcss.config.js
public/privacy-policy.md
public/vite.svg
README.md
src/App.vue
src/assets/vue.svg
src/components/conversation-view/CopyMessageButton.vue
src/components/conversation-view/EmptyState.vue
src/components/conversation-view/MessageBubble.vue
src/components/conversation-view/MessageHeader.vue
src/components/conversation-view/MessageInput.vue
src/components/conversation-view/MessageView.vue
src/components/ConversationList.vue
src/components/LoginDialog.vue
src/components/LogoutDialog.vue
src/components/MessagesMainView.vue
src/components/NewMessageDialog.vue
src/components/PrivacyPolicy.vue
src/main.js
src/services/encryption.service.js
src/services/google.service.js
src/style.css
src/utils/auth.js
tailwind.config.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/privacy-policy.md">
# מדיניות פרטיות

## מבוא

מסמך זה מפרט את אופן האיסוף, השימוש והאחסון של מידע אישי בתוכנה סמייל פרו - תצוגת שיחות. חשוב להדגיש כי האמור לקמן מתייחס לממשק זה בלבד ולא לתוכנת סמייל פרו - שליחת SMS למייל.

## איסוף מידע

### המידע שנאסף

• פרטי התחברות לשירותי ימות המשיח (מספר מערכת וסיסמה)  
• תוכן הודעות SMS נשלחות ונתקבלות  
• רשימת אנשי קשר (אופציונלי, מ-Google Contacts)  
• נתוני הרשאה זמניים עבור Google APIs  

### מקומות שבהם מאוחסן המידע שנאסף

• פרטי התחברות: אחסון מקומי בדפדפן בלבד (localStorage)  
• הודעות SMS: שרתי ימות המשיח בע"מ  
• אנשי קשר: Google Contacts ושרתי ימות המשיח  

## שימוש במידע

המידע משמש אך ורק לצורך הפעילות התקינה והרציפה של התוכנה, בשום שלב לא נעשה ו/או יעשה שימוש בנתונים שלכם לרבות תוכן ההודעות שהתקבלו או נשלחו באמצעות התוכנה לשום שימוש אחר מלבד הצגתם בתוכנה

## שיתוף מידע

המידע הנאסף מאוחסן בחשבון הGoogle האישי שלכם ובמערכת שלכם בשרתי ימות המשיח בלבד. המידע אינו משותף עם גורמים חיצוניים כלל גם לא עם יוצרי ומפעילי התוכנה.

המערכת פועלת כממשק ישיר בלבד. כל המידע נשמר אצל ספקי השירות המקוריים (ימות המשיח, Google) או באחסון מקומי של המשתמש.

## יצירת קשר

לשאלות או הבהרות בנוגע למדיניות הפרטיות ניתן לפנות אלינו בדוא"ל cs@abaye.co

## הסכמת המשתמש

השימוש במערכת מהווה הסכמה למדיניות פרטיות זו, כל מחלוקת הנוגעת לתנאים או לשימוש בתוכנה תתברר בבי"ד הדן על פי תורת ישראל המקובל על הצדדים
</file>

<file path="src/components/conversation-view/CopyMessageButton.vue">
<template>
    <button @click="copy" class="p-1.5 rounded-full text-gray-400 hover:text-gray-700 hover:bg-gray-100 transition" :title="copied ? 'הועתק!' : 'העתק הודעה'">
        <template v-if="copied">
            <CheckCheck class="h-5 w-5 text-green-500" />
        </template>
        <template v-else>
            <Files class="h-5 w-5" />
        </template>
    </button>
</template>

<script setup>
import { ref } from 'vue';
import { Files, CheckCheck } from 'lucide-vue-next';


const props = defineProps({
    text: {
        type: String,
        required: true,
    },
});

const copied = ref(false);

function copy() {
    navigator.clipboard.writeText(props.text).then(() => {
        copied.value = true;
        setTimeout(() => {
            copied.value = false;
        }, 1250);
    });
}
</script>
</file>

<file path="src/components/conversation-view/EmptyState.vue">
<template>
    <div class="flex-1 flex flex-col items-center justify-between text-gray-500 py-16">
        <div></div>

        <div class="flex flex-col items-center">
            <svg class="w-16 h-16 text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                    d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z">
                </path>
            </svg>
            <h3 class="text-lg font-medium text-gray-700 mb-1">הודעות SMS</h3>
            <p class="text-gray-500 text-center mb-4">בחר שיחה בכדי להתחיל לשוחח</p>
        </div>

        <div class="text-sm text-gray-600 bg-gray-100 py-2 px-4 rounded-lg gap-2 flex">
            <p>מחובר כ-{{ username }}</p>
            <p>|</p>
            <button @click="emit('logout')" class="text-indigo-600 hover:text-indigo-800 transition">
                התנתק
            </button>
            <p>|</p>
            <button @click="openPrivacyPolicy()" class="text-indigo-600 hover:text-indigo-800 transition">
                מדיניות הפרטיות
            </button>
        </div>
    </div>
</template>

<script setup>
const props = defineProps({
    username: {
        type: String,
        required: true
    }
});

const emit = defineEmits(['logout']);

const openPrivacyPolicy = () => {
    window.openPrivacyPolicy();
};
</script>
</file>

<file path="src/components/conversation-view/MessageBubble.vue">
<template>
    <div class="flex flex-col gap-1">
        <!-- Message Row -->
        <div :class="[
            'flex group',
            message.type === 'outgoing' ? 'justify-end' : 'justify-start'
        ]">
            <!-- Copy Button for Outgoing Message -->
            <div v-if="message.type === 'outgoing'" class="group-hover:flex items-center ml-2 hidden">
                <CopyMessageButton :text="message.content" />
            </div>

            <!-- Message Bubble -->
            <div :class="[
                'max-w-[70%] rounded-lg px-4 py-2 shadow-sm',
                message.type === 'outgoing'
                    ? 'bg-indigo-600 text-white'
                    : 'bg-indigo-50 text-gray-900 border border-gray-100'
            ]">
                <!-- Message Content -->
                <p 
                    class="whitespace-pre-line text-[16px]" 
                    v-html="formatMessageContent(message.content, message.type)">
                </p>

                <!-- Verification Code Button (if exists) -->
                <div 
                    v-if="message.type === 'incoming' && verificationCode" 
                    class="mt-2">
                    <button 
                        @click="copyVerificationCode(verificationCode, message.id)"
                        class="flex items-center gap-1 text-xs bg-indigo-600 text-white px-2 py-1 rounded-full hover:bg-indigo-700 transition-colors"
                        v-tippy="'העתק קוד אימות'">
                        <Files class="h-3 w-3" />
                        <span v-if="copiedCodeId === message.id">הועתק!</span>
                        <span v-else>{{ verificationCode }}</span>
                    </button>
                </div>
            </div>

            <!-- Copy Button for Incoming Messages -->
            <div v-if="message.type === 'incoming'" class="group-hover:flex items-center mr-2 hidden">
                <CopyMessageButton :text="message.content" />
            </div>
        </div>

        <!-- Time and Status Row (Outside bubble) -->
        <div :class="[
            'flex items-center gap-1 px-1',
            message.type === 'outgoing' ? 'justify-end' : 'justify-start'
        ]">
            <!-- Time -->
            <p class="text-xs text-gray-500">
                {{ formattedTime }}
            </p>

            <!-- Status for Outgoing Messages -->
            <span 
                v-if="message.type === 'outgoing'" 
                class="text-gray-500">
                <div 
                    v-if="message.status === 'DELIVRD'" 
                    class="flex" 
                    v-tippy="'נמסר'">
                    <CheckIcon class="h-3 w-3" />
                    <CheckIcon class="h-3 w-3 -mr-2" />
                </div>
                <CheckIcon 
                    v-else 
                    class="h-3 w-3" 
                    v-tippy="'נשלח'" />
            </span>
        </div>
    </div>
</template>

<script setup>
import { computed } from 'vue';
import { format, isToday, differenceInDays } from 'date-fns';
import { he } from 'date-fns/locale';
import { Files } from 'lucide-vue-next';
import { CheckIcon } from '@heroicons/vue/24/solid';
import CopyMessageButton from './CopyMessageButton.vue';

const props = defineProps({
    message: {
        type: Object,
        required: true
    },
    copiedCodeId: {
        type: String,
        default: null
    }
});

const emit = defineEmits(['copy-verification-code']);

// Format message time
const formattedTime = computed(() => {
    const date = new Date(props.message.timestamp);
    const time = format(date, 'HH:mm');

    if (isToday(date)) {
        return `היום, ${time}`;
    }

    const daysDifference = differenceInDays(new Date(), date);

    if (daysDifference <= 6) {
        const daysInHebrew = ['ימים', 'יום', 'יומיים', 'שלושה ימים', 'ארבעה ימים', 'חמישה ימים', 'שישה ימים', 'שבעה ימים'];
        return `לפני ${daysInHebrew[daysDifference + 1]}, ${time}`;
    }

    return format(date, "d בMMMM yyyy', 'HH:mm", { locale: he });
});

// Extract verification code
const verificationCode = computed(() => {
    if (!props.message.content || typeof props.message.content !== 'string') {
        return null;
    }

    const numbers = props.message.content.match(/\b\d{4,8}\b/g);

    if (!numbers) return null;

    for (const number of numbers) {
        const numberIndex = props.message.content.indexOf(number);
        const beforeChar = props.message.content.charAt(numberIndex - 1);

        if (beforeChar === '-' || beforeChar === ' ') {
            const beforeText = props.message.content.substring(Math.max(0, numberIndex - 5), numberIndex);
            if (/\d+[-\s]$/.test(beforeText)) {
                continue;
            }
        }

        if (number.length >= 7 && (
            number.startsWith('05') ||
            number.startsWith('02') ||
            number.startsWith('03') ||
            number.startsWith('04') ||
            number.startsWith('08') ||
            number.startsWith('09') ||
            number.startsWith('077') ||
            number.startsWith('072') ||
            number.startsWith('073')
        )) {
            continue;
        }

        if (number.length >= 5 && number.length <= 8) {
            return number;
        }

        if (number.length === 4) {
            if (/(?:קוד|הקוד|code|pin|otp|verification|אימות)/i.test(props.message.content)) {
                return number;
            }
        }
    }

    return null;
});

// Format message content with links
const formatMessageContent = (content, type) => {
    if (type === 'incoming') {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return content.replace(
            urlRegex,
            (url) => `<a href="${url}" target="_blank" class="text-indigo-600 hover:text-indigo-500 underline">${url}</a>`
        );
    } else if (type === 'outgoing') {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return content.replace(
            urlRegex,
            (url) => `<a href="${url}" target="_blank" class="underline">${url}</a>`
        );
    }
    return content;
};

// Copy verification code
const copyVerificationCode = (code, messageId) => {
    emit('copy-verification-code', code, messageId);
};
</script>
</file>

<file path="src/components/conversation-view/MessageHeader.vue">
<template>
  <div class="border-b border-gray-200 p-4 flex justify-between items-center sticky top-0 bg-white z-10 shadow-sm">
    <!-- Left Side - Contact Info -->
    <div class="space-x-3 space-x-reverse flex items-center">
      <button 
        class="p-1.5 rounded-full text-gray-500 hover:bg-gray-100 md:hidden transition" 
        v-tippy="'חזור'"
        @click="emit('back')">
        <ArrowUturnLeftIcon class="h-5 w-5" />
      </button>

      <div class="relative">
        <img 
          :src="conversation.avatar" 
          alt="" 
          class="h-10 w-10 rounded-full border border-gray-200 shadow-sm" />
        <div 
          v-if="conversation.unreadCount > 0"
          class="absolute -top-1 -right-1 flex-shrink-0 w-5 h-5 bg-indigo-500 rounded-full flex items-center justify-center ring-2 ring-white">
          <span class="text-xs text-white font-medium">
            {{ conversation.unreadCount }}
          </span>
        </div>
      </div>

      <div class="-my-1">
        <h2 class="text-lg font-medium text-gray-900">
          {{ conversation.name }}
        </h2>
        <h3 
          v-if="conversation.name !== conversation.contact" 
          class="text-xs text-gray-500">
          {{ conversation.contact }}
        </h3>
      </div>
    </div>

    <!-- Right Side - Action Buttons -->
    <div class="flex items-center gap-2">
      <button 
        class="p-1.5 rounded-full text-gray-500 hover:bg-gray-100 transition" 
        v-tippy="'רענן הודעות'"
        @click="emit('refresh')">
        <ArrowPathIcon class="h-5 w-5" />
      </button>

      <button 
        class="p-1.5 rounded-full text-gray-500 hover:bg-gray-100 transition" 
        v-tippy="'התנתק'" 
        @click="emit('logout')">
        <PowerIcon class="h-5 w-5" />
      </button>
    </div>
  </div>
</template>

<script setup>
import { ArrowUturnLeftIcon, ArrowPathIcon, PowerIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  conversation: {
    type: Object,
    required: true
  }
});

const emit = defineEmits(['back', 'refresh', 'logout']);
</script>
</file>

<file path="src/components/conversation-view/MessageInput.vue">
<template>
    <div class="p-4 sticky bottom-0 bg-white shadow-sm">
        <div class="flex items-center gap-3">
            <div class="flex-1 relative">
                <textarea v-model="message" :placeholder="getPlaceholderText()" rows="1" :class="[
                    'w-full rounded-full py-3 focus:outline-none focus:ring-1 transition-all resize-none',
                    isNumberAllowSending
                        ? 'bg-gray-50 border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 text-gray-900 p-6'
                        : 'bg-red-50 border border-red-300 focus:ring-red-500 focus:border-red-500 text-red-700 placeholder-red-400 p-6'
                ]" @keydown.enter.meta.prevent="handleSend" @keydown.enter.ctrl.prevent="handleSend"
                    :disabled="!isNumberAllowSending" />
            </div>

            <!-- Send Button -->
            <button @click="handleSend" :disabled="!message.trim() || sending || !isNumberAllowSending"
                class="flex items-center gap-2 px-6 py-3 rounded-full transition-all shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 font-medium min-w-[80px]"
                :class="[
                    !message.trim() || sending || !isNumberAllowSending
                        ? 'bg-indigo-300 cursor-not-allowed text-white'
                        : 'bg-indigo-600 text-white hover:bg-indigo-700 active:bg-indigo-800'
                ]" v-tippy="getButtonTooltip()">

                <!-- Normal State -->
                <template v-if="!sending">
                    <SendHorizontal class="h-4 w-4 rotate-180" />
                    <span>שלח</span>
                </template>

                <!-- Loading State -->
                <template v-else>
                    <LoaderCircle class="h-4 w-4 animate-spin" />
                    <span>שולח</span>
                </template>
            </button>
        </div>
    </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue';
import { getAuthToken } from '../../utils/auth.js';
import { SendHorizontal, LoaderCircle, PenOff } from 'lucide-vue-next';
import { PencilIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
    phoneNumber: {
        type: String,
        required: true
    }
});

const emit = defineEmits(['message-sent', 'send-error']);

const message = ref('');
const sending = ref(false);

// Clear message when phone number changes (conversation switch)
watch(() => props.phoneNumber, () => {
    message.value = '';
});

// Use computed instead of ref to make it reactive to props changes
const isNumberAllowSending = computed(() => {
    return props.phoneNumber.startsWith('0') || props.phoneNumber.startsWith('+');
});

// Dynamic placeholder text based on phone number validity
const getPlaceholderText = () => {
    if (!isNumberAllowSending.value) {
        return `לא ניתן לשלוח הודעות למספר ${props.phoneNumber}`;
    }
    return 'הקלד הודעה...';
};

// Function to get appropriate tooltip text
const getButtonTooltip = () => {
    if (!isNumberAllowSending.value) {
        return 'לא ניתן לשלוח למספר זה';
    }
    if (sending.value) {
        return 'שולח הודעה...';
    }
    if (!message.value.trim()) {
        return 'הקלד הודעה כדי לשלוח';
    }
    return 'שלח הודעה (Ctrl+Enter)';
};

const handleSend = async () => {
    if (!message.value.trim() || !isNumberAllowSending.value) return;

    sending.value = true;

    try {
        const authToken = await getAuthToken();
        if (!authToken) {
            console.error('No authentication token available for sending message');
            emit('send-error', 'שגיאה: לא נמצא טוקן אימות');
            sending.value = false;
            return;
        }

        const response = await fetch(
            `https://www.call2all.co.il/ym/api/SendSms?token=${authToken}&phones=${props.phoneNumber}&message=${message.value}`
        );

        const data = await response.json();

        if (data.responseStatus === 'OK') {
            const sentMessage = message.value;
            message.value = '';
            sending.value = false;
            emit('message-sent', sentMessage);
        } else {
            sending.value = false;
            emit('send-error', 'שגיאה בשליחת ההודעה: ' + data.message);
        }
    } catch (error) {
        sending.value = false;
        emit('send-error', 'שגיאה בשליחת ההודעה: ' + error.message);
    }
};

// Expose message value for parent component if needed
defineExpose({
    clearMessage: () => {
        message.value = '';
    },
    getMessage: () => message.value
});
</script>
</file>

<file path="src/components/conversation-view/MessageView.vue">
<template>
  <div :class="[
    !selectedId ? 'pr-0 md:pr-96' : 'pr-0 md:pr-96',
    'flex-1 flex flex-col h-full z-20 relative'
  ]">
    <div v-if="conversation" class="flex-1 flex flex-col">
      <!-- Header -->
      <MessageHeader 
        :conversation="conversation"
        @back="emit('back')"
        @refresh="emit('refreshMessages')"
        @logout="emit('logout')" />

      <!-- Messages Container -->
      <div 
        ref="messagesContainer" 
        class="flex-1 overflow-y-auto p-4 space-y-4 bg-white">
        <MessageBubble
          v-for="msg in conversation.messages"
          :key="msg.id"
          :message="msg"
          :copied-code-id="copiedCodeId"
          @copy-verification-code="handleCopyVerificationCode" />
      </div>

      <!-- Message Input -->
      <MessageInput 
        :phone-number="conversation.contact"
        @message-sent="handleMessageSent"
        @send-error="handleSendError" />

      <!-- Scroll to bottom button -->
      <transition name="fade">
        <button 
          v-if="showScrollButton" 
          @click="scrollToBottom"
          class="fixed bottom-24 right-1/2 transform translate-x-1/2 z-20 bg-indigo-600 text-white border-gray-300 text-sm px-4 py-2 border rounded-full shadow-md hover:bg-indigo-500 transition-all"
          v-tippy="'חזור למטה'">
          חזור למטה
        </button>
      </transition>
    </div>

    <!-- Empty State -->
    <EmptyState 
      v-else
      :username="username"
      @logout="emit('logout')" />
  </div>
</template>

<script setup>
import { ref, onMounted, watch, nextTick } from 'vue';
import MessageHeader from './MessageHeader.vue';
import MessageBubble from './MessageBubble.vue';
import MessageInput from './MessageInput.vue';
import EmptyState from './EmptyState.vue';

const props = defineProps({
  conversation: {
    type: Object,
    default: null
  },
  username: {
    type: String,
    default: ''
  },
  selectedId: {
    type: String,
    default: null
  }
});

const emit = defineEmits(['refreshMessages', 'back', 'logout']);

const messagesContainer = ref(null);
const showScrollButton = ref(false);
const copiedCodeId = ref(null);

// Watch for conversation changes and scroll to bottom
watch(() => props.conversation, () => {
  nextTick(() => {
    scrollToBottom();
  });
}, { deep: true });

// Setup scroll listener on mount
onMounted(() => {
  if (messagesContainer.value) {
    messagesContainer.value.addEventListener('scroll', handleScroll);
  }
});

// Handle scroll to show/hide scroll button
function handleScroll() {
  if (!messagesContainer.value) return;

  const { scrollTop, scrollHeight, clientHeight } = messagesContainer.value;
  // Show button when scrolled up more than 200px from bottom
  showScrollButton.value = scrollHeight - scrollTop - clientHeight > 200;
}

// Scroll to bottom of messages
function scrollToBottom() {
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
}

// Handle verification code copy
const handleCopyVerificationCode = (code, messageId) => {
  navigator.clipboard.writeText(code).then(() => {
    copiedCodeId.value = messageId;
    setTimeout(() => {
      copiedCodeId.value = null;
    }, 2000);
    console.log('קוד אימות הועתק:', code);
  }).catch(err => {
    console.error('שגיאה בהעתקת קוד האימות:', err);
  });
};

// Handle successful message send
const handleMessageSent = (sentMessage) => {
  emit('refreshMessages');
  nextTick(() => {
    scrollToBottom();
  });
  console.log('הודעה נשלחה:', sentMessage);
};

// Handle send error
const handleSendError = (errorMessage) => {
  alert(errorMessage);
};
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
</file>

<file path="src/components/LoginDialog.vue">
<template>
    <transition name="fade">
        <div v-if="visible" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-50 p-4"
            style="backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">

            <div class="bg-white p-8 rounded-xl shadow-xl w-full max-w-md" @click.stop>
                <div class="flex flex-col items-center mb-6">
                    <div class="w-12 h-12 bg-indigo-100 rounded-full flex items-center justify-center mb-4">
                        <KeyIcon class="h-6 w-6 text-indigo-600" />
                    </div>
                    <h3 class="text-2xl font-bold text-gray-800">התחברות למערכת</h3>
                    <p class="text-gray-500 mt-1 text-center">הזן את פרטי ההתחברות שלך כדי להתחיל</p>
                </div>

                <div v-if="error" class="mb-4 p-3 bg-red-50 border border-red-200 text-red-700 rounded-lg text-sm">
                    {{ error }}
                </div>

                <form @submit.prevent="handleLogin" class="space-y-4">
                    <label for="username"
                        class="relative block overflow-hidden rounded-lg border border-gray-200 px-3 pt-3 shadow-sm focus-within:border-indigo-600 focus-within:ring-1 focus-within:ring-indigo-600 transition-colors cursor-text">
                        <input v-model="username" type="text" id="username" placeholder="מה מספר המערכת שלך?"
                            :autofocus="shouldFocus" required
                            class="peer h-10 w-full border-none bg-transparent p-0 placeholder-transparent focus:placeholder-gray-400 focus:border-transparent focus:outline-none focus:ring-0 sm:text-sm text-gray-900" />
                        <span
                            class="absolute start-3 top-3 -translate-y-1/2 text-xs text-gray-500 transition-all peer-placeholder-shown:top-1/2 peer-placeholder-shown:text-sm peer-focus:top-3 peer-focus:text-xs">
                            מספר מערכת
                        </span>
                    </label>

                    <label for="password"
                        class="relative block overflow-hidden rounded-lg border border-gray-200 px-3 pt-3 shadow-sm focus-within:border-indigo-600 focus-within:ring-1 focus-within:ring-indigo-600 transition-colors cursor-text">
                        <input v-model="password" type="password" id="password" placeholder="מה הסיסמא שלך?" required
                            class="peer h-10 w-full border-none bg-transparent p-0 placeholder-transparent focus:placeholder-gray-400 focus:border-transparent focus:outline-none focus:ring-0 sm:text-sm text-gray-900" />
                        <span
                            class="absolute start-3 top-3 -translate-y-1/2 text-xs text-gray-500 transition-all peer-placeholder-shown:top-1/2 peer-placeholder-shown:text-sm peer-focus:top-3 peer-focus:text-xs">
                            סיסמא
                        </span>
                    </label>

                    <button type="submit" :disabled="loading" :class="[
                        loading ? 'bg-opacity-70 cursor-not-allowed' : 'hover:bg-indigo-500',
                        'mt-6 transition-all w-full px-4 py-3 text-white bg-indigo-600 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 font-medium'
                    ]">
                        <span v-if="!loading">כניסה למערכת</span>
                        <span v-else class="flex justify-center items-center">
                            <svg class="animate-spin -mr-1 ml-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg"
                                fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                            בודק את הפרטים...
                        </span>
                    </button>

                    <div class="text-sm text-center pt-2 text-indigo-600">
                        <span class="hover:underline cursor-pointer" @click="openPrivacyPolicy">מדיניות פרטיות</span>
                    </div>
                </form>
            </div>
        </div>
    </transition>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { saveCredentials } from '../services/encryption.service';
import { KeyIcon, XMarkIcon } from '@heroicons/vue/24/outline';


const props = defineProps({
    visible: {
        type: Boolean,
        default: false
    },
    shouldFocus: {
        type: Boolean,
        default: false
    }
});

const emit = defineEmits(['login-success', 'login-error']);

const username = ref('');
const password = ref('');
const loading = ref(false);
const error = ref('');

// Initialize username from credentials if exists
const initializeUsername = async () => {
    const { getSavedCredentials } = await import('../services/encryption.service');
    const credentials = await getSavedCredentials();
    if (credentials && credentials.username) {
        username.value = credentials.username;
    }
};

// Initialize when component becomes visible
watch(() => props.visible, (newVisible) => {
    if (newVisible) {
        initializeUsername();
        error.value = '';
        nextTick(() => {
            if (!username.value && props.shouldFocus) {
                document.getElementById('username')?.focus();
            }
        });
    }
});

const openPrivacyPolicy = () => {
    window.openPrivacyPolicy();
};

const handleLogin = async () => {
    loading.value = true;
    error.value = '';

    if (!username.value || !password.value) {
        error.value = 'כל השדות הינם שדות חובה!';
        loading.value = false;
        return;
    }

    try {
        const response = await fetch(`https://www.call2all.co.il/ym/api/GetSession?token=${username.value}:${password.value}`);
        const data = await response.json();

        if (data.responseStatus === 'OK') {
            // הצפן ושמור את פרטי ההתחברות באמצעות השירות החדש
            const saveSuccess = await saveCredentials(username.value, password.value);

            if (!saveSuccess) {
                error.value = 'שגיאה בשמירת פרטי ההתחברות';
                loading.value = false;
                return;
            }

            // עדכן את כותרת הדף
            document.title = 'מערכת סמסים - ' + username.value;

            // אפס את הטופס
            password.value = '';
            loading.value = false;

            emit('login-success', username.value);
        } else {
            error.value = 'שגיאה בהתחברות: ' + data.message;
            loading.value = false;
        }
    } catch (err) {
        error.value = 'שגיאת התחברות. אנא נסה שוב מאוחר יותר.';
        console.error('Login error:', err);
        loading.value = false;
    }
};
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}
</style>
</file>

<file path="src/components/LogoutDialog.vue">
<template>
  <transition name="fade">
    <div 
      v-if="visible"
      @click="handleCancel"
      class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      style="backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">

      <div 
        class="bg-white rounded-2xl shadow-2xl w-full max-w-md transform transition-all" 
        @click.stop>
        
        <!-- Header -->
        <div class="p-6 text-center border-b border-gray-100">
          <div class="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <PowerIcon class="h-6 w-6 text-red-600" />
          </div>
          
          <h3 class="text-xl font-bold text-gray-900 mb-2">
            התנתקות מהמערכת
          </h3>
          
          <p class="text-gray-600">
            האם אתה בטוח שברצונך להתנתק מהמערכת?
          </p>
        </div>

        <!-- Content -->
        <div class="p-6">
          <div class="p-4">
            <div class="flex items-center justify-center">
              <span class="text-lg text-gray-600">כעת אתה מחובר כמשתמש:
                <span class="text-lg font-medium text-indigo-600">{{ username }}</span>
              </span>
            </div>
          </div>

          <!--div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
            <div class="flex">
              <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
              </div>
              <div class="mr-3">
                <p class="text-sm text-amber-800">
                  לאחר ההתנתקות תצטרך להזין שוב את פרטי ההתחברות
                </p>
              </div>
            </div>
          </div-->
        </div>

        <!-- Actions -->
        <div class="flex gap-3 p-6 bg-gray-50 rounded-b-2xl">
          <button 
            @click="handleCancel"
            class="flex-1 px-4 py-3 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors font-medium">
            ביטול
          </button>
          
          <button 
            @click="handleConfirm"
            class="flex-1 px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors font-medium">
            כן, התנתק
          </button>
        </div>
      </div>
    </div>
  </transition>
</template>

<script setup>
import { PowerIcon, XMarkIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  username: {
    type: String,
    default: ''
  }
});

const emit = defineEmits(['confirm', 'cancel']);

const handleConfirm = () => {
  emit('confirm');
};

const handleCancel = () => {
  emit('cancel');
};
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.fade-enter-active .transform,
.fade-leave-active .transform {
  transition: transform 0.3s ease;
}

.fade-enter-from .transform {
  transform: scale(0.95) translateY(-10px);
}

.fade-leave-to .transform {
  transform: scale(0.95) translateY(-10px);
}
</style>
</file>

<file path="src/components/MessagesMainView.vue">
<template>
  <div class="flex h-full bg-gray-50 relative">
    <MessageView 
      :conversation="selectedConversation" 
      @refresh-messages="refreshMessages" 
      :username="username"
      :selected-id="selectedConversationId" 
      @back="selectedConversation = null, selectedConversationId = null"
      @logout="handleLogoutRequest" />

    <ConversationList 
      :conversations="conversations" 
      :selected-id="selectedConversationId"
      @select="handleConversationSelect" 
      @refresh-messages="refreshMessages" 
      @filter="filterConversations" 
      @mark-all-as-read="markAllAsRead" />

    <LogoutDialog 
      :visible="logoutDialogVisible"
      :username="username"
      @confirm="handleLogoutConfirm"
      @cancel="handleLogoutCancel" />
  </div>
</template>

<script setup>
import { ref, watchEffect, nextTick } from 'vue';
import ConversationList from './ConversationList.vue';
import MessageView from './conversation-view/MessageView.vue';
import LogoutDialog from './LogoutDialog.vue';
import { getSavedCredentials } from '../services/encryption.service';
import {
  getGoogleContacts,
  checkGoogleAuthStatus
} from '../services/google.service';
import { getAuthToken } from '../utils/auth.js';


const props = defineProps({
  username: {
    type: String,
    required: true
  }
});

const emit = defineEmits(['logout']);

const conversations = ref([]);
const selectedConversationId = ref(null);
const selectedConversation = ref(null);
const setRead = ref(null);
const logoutDialogVisible = ref(false);

const googleAuthStatus = ref({
  isAuthenticated: false,
  userEmail: '',
  contactCount: 0
});

const handleConversationSelect = (id) => {
  console.log('Selected conversation ID:', id);

  setRead.value = null;

  selectedConversationId.value = String(id);
  selectedConversation.value = conversations.value.find(c => String(c.id) === String(id)) || null;

  console.log('After select - selectedId:', selectedConversationId.value);
  console.log('Found conversation:', selectedConversation.value ? selectedConversation.value.id : 'none');

  watchEffect(() => {
    nextTick(() => {
      window.scrollTo(0, document.body.scrollHeight);
    });
  }, {
    flush: 'post'
  });

  setRead.value = setTimeout(async () => {
    const readedArray = [];
    const incomingMessages = selectedConversation.value.messages.filter(message => message.type === 'incoming');

    incomingMessages.forEach((message) => {
      if (!message.read) {
        readedArray.push({
          phone: message.sender,
          message: message.message,
          server_date: new Date(message.timestamp).getTime()
        });
      }
    });

    if (readedArray.length > 0) {
      try {
        const authToken = await getAuthToken();
        if (!authToken) {
          console.error('No authentication token available');
          return;
        }

        const readedMessagesFetch = await fetch(
          `https://www.call2all.co.il/ym/api/GetTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini`
        );

        const readedMessagesRes = await readedMessagesFetch.json();
        let readedMessages = [];

        if (readedMessagesRes.message === "file does not exist") {
          await fetch(
            `https://www.call2all.co.il/ym/api/UploadTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini&contents=${JSON.stringify(readedArray)}`
          );
        } else {
          const readedMessagesData = readedMessagesRes.contents;
          const readedMessagesObj = JSON.parse(readedMessagesData);

          readedMessages = readedMessagesObj;
          readedMessages = readedMessages.concat(readedArray);

          await fetch(`https://www.call2all.co.il/ym/api/UploadTextFile`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              token: authToken,
              what: 'ivr2:YemotSMSInboxReadedMessages.ini',
              contents: JSON.stringify(readedMessages)
            })
          });

          conversations.value = conversations.value.map(conversation => {
            if (conversation.id === id) {
              conversation.unreadCount = 0;
            }
            return conversation;
          });
        }
      } catch (error) {
        console.error('Error marking messages as read:', error);
      }
    }
  }, 1000);
};

async function checkNewMessages() {
  try {
    const authToken = await getAuthToken();
    if (!authToken) {
      console.error('No authentication token available for checking new messages');
      return;
    }

    const response = await fetch(
      `https://www.call2all.co.il/ym/api/GetIncomingSms?token=${authToken}&limit=1`
    );

    const data = await response.json();
    const message = data.rows[0];

    const lastMessage = localStorage.getItem('lastMessage');
    if (lastMessage === JSON.stringify(message)) {
      return;
    }

    new Notification(
      message.source.startsWith('972') ? '0' + message.source.substring(3) : message.source,
      { body: message.message }
    );

    localStorage.setItem('lastMessage', JSON.stringify(message));
    await refreshMessages();
  } catch (error) {
    console.error('Error checking for new messages:', error);
  }
}

async function getMessages() {
  try {
    console.log('Getting messages and refreshing data...');

    const authToken = await getAuthToken();
    if (!authToken) {
      console.error('No authentication token available for getting messages');
      return;
    }

    const incoming = await fetch(
      `https://www.call2all.co.il/ym/api/GetIncomingSms?token=${authToken}&limit=3000`
    );

    const outgoing = await fetch(
      `https://www.call2all.co.il/ym/api/GetSmsOutLog?token=${authToken}&limit=999999`
    );

    let contacts = {};

    const googleContactsResult = await getGoogleContacts();

    if (googleContactsResult.isAuthenticated && googleContactsResult.contacts) {
      googleContactsResult.contacts.forEach(contact => {
        if (contact.phone && contact.name) {
          contacts[contact.phone] = contact.name;
        }
      });

      googleAuthStatus.value = {
        isAuthenticated: true,
        userEmail: googleContactsResult.userData?.email || '',
        contactCount: googleContactsResult.contacts.length
      };
    } else {
      googleAuthStatus.value = {
        isAuthenticated: false,
        userEmail: '',
        contactCount: 0
      };
    }

    const readedMessagesFetch = await fetch(
      `https://www.call2all.co.il/ym/api/GetTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini`
    );

    const readedMessagesRes = await readedMessagesFetch.json();
    let readedMessages = [];

    if (readedMessagesRes.message === "file does not exist") {
      await fetch(
        `https://www.call2all.co.il/ym/api/UploadTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini&contents=${JSON.stringify([])}`
      );
    } else {
      const readedMessagesData = readedMessagesRes.contents;
      const readedMessagesObj = JSON.parse(readedMessagesData);
      readedMessages = readedMessagesObj;
    }

    const incomingMsgs = (await incoming.json()).rows || [];
    const outgoingMsgs = (await outgoing.json()).rows || [];

    const incomingMessages = incomingMsgs.map((message) => {
      const phone = message.source.startsWith('972') ? '0' + message.source.substring(3) : message.source;
      return {
        ...message,
        dest: message.destination,
        phone: phone,
        server_date: message.receive_date,
        type: 'incoming',
        status: 'DELIVRD'
      };
    });

    const outgoingMessages = outgoingMsgs.map((message) => {
      return {
        dest: message.CallerId,
        phone: message.To,
        message: message.Message,
        server_date: message.Time,
        status: message.DeliveryReport,
        type: 'outgoing'
      };
    });

    localStorage.setItem('lastMessage', JSON.stringify(incomingMsgs[0]));
    conversations.value = [];

    let messages = incomingMessages.concat(outgoingMessages);
    messages.sort((a, b) => new Date(b.server_date) - new Date(a.server_date));

    const messagesBySender = messages.reduce((acc, message) => {
      const sender = message.phone;
      if (!acc[sender]) {
        acc[sender] = [];
      }
      acc[sender].push(message);
      return acc;
    }, {});

    const usedIds = new Set();

    for (let conversation of removeDuplicates(messages, 'phone')) {
      const lastMessageData = messagesBySender[conversation.phone][0];

      let uniqueId = crypto.randomUUID();
      while (usedIds.has(uniqueId)) {
        uniqueId = crypto.randomUUID();
      }
      usedIds.add(uniqueId);

      const msgs = messagesBySender[conversation.phone].reverse().map((message) => {
        let msgUniqueId = crypto.randomUUID();
        while (usedIds.has(msgUniqueId)) {
          msgUniqueId = crypto.randomUUID();
        }
        usedIds.add(msgUniqueId);

        return {
          id: msgUniqueId,
          sender: message.phone,
          content: message.message,
          timestamp: new Date(message.server_date),
          read: readedMessages.some(readedMessage =>
            readedMessage.phone === message.phone &&
            readedMessage.message === message.message &&
            readedMessage.server_date === new Date(message.server_date).getTime()
          ),
          avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=' + message.phone,
          type: message.type,
          status: message.status,
        };
      });

      let lastMsgUniqueId = crypto.randomUUID();
      while (usedIds.has(lastMsgUniqueId)) {
        lastMsgUniqueId = crypto.randomUUID();
      }
      usedIds.add(lastMsgUniqueId);

      conversations.value.push({
        id: String(uniqueId),
        contact: conversation.phone,
        name: contacts[conversation.phone] || conversation.phone,
        avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=' + conversation.phone,
        lastMessage: {
          id: lastMsgUniqueId,
          sender: lastMessageData.phone,
          content: lastMessageData.message,
          timestamp: new Date(lastMessageData.server_date),
          read: readedMessages.some(readedMessage =>
            readedMessages.phone === lastMessageData.phone &&
            readedMessages.message === lastMessageData.message &&
            readedMessages.server_date === new Date(lastMessageData.server_date).getTime()
          ),
          avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=' + lastMessageData.phone,
          type: lastMessageData.type,
          status: lastMessageData.status,
        },
        messages: msgs,
        unreadCount: msgs.filter((message) => message.type == 'incoming' && message.read == false).length,
      });
    }

    console.log('Created conversations:', conversations.value.map(c => ({ id: c.id, name: c.name })));

    window.dispatchEvent(new CustomEvent('googleAuthStatusUpdated'));
  } catch (err) {
    console.error('Error getting messages:', err);
  }
}

async function refreshMessages() {
  const phone = selectedConversation.value?.contact;
  await getMessages();

  if (phone) {
    handleConversationSelect(conversations.value.find(c => c.contact === phone)?.id || '');
  }
}

function filterConversations(filter) {
  const filtered = conversations.value.filter(conversation => conversation.unreadCount > 0);

  if (!filtered.length) return;

  if (filter) {
    conversations.value = filtered;
  } else {
    getMessages();
  }
}

function removeDuplicates(array, key) {
  return Array.from(
    new Map(array.map((item) => [item[key], item])).values()
  );
}

async function markAllAsRead() {
  try {
    const authToken = await getAuthToken();
    if (!authToken) {
      console.error('No authentication token available for marking messages as read');
      return;
    }

    // איסוף כל ההודעות הנכנסות שלא נקראו
    const allUnreadMessages = [];
    
    conversations.value.forEach(conversation => {
      const unreadIncomingMessages = conversation.messages.filter(
        message => message.type === 'incoming' && !message.read
      );
      
      unreadIncomingMessages.forEach(message => {
        console.log(message)
        allUnreadMessages.push({
          phone: message.sender,
          message: message.content,
          server_date: new Date(message.timestamp).getTime()
        });
      });
    });

    if (allUnreadMessages.length === 0) {
      console.log('No unread messages to mark as read');
      return;
    }

    // קבלת ההודעות הנקראות הקיימות
    const readedMessagesFetch = await fetch(
      `https://www.call2all.co.il/ym/api/GetTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini`
    );

    const readedMessagesRes = await readedMessagesFetch.json();
    let readedMessages = [];

    if (readedMessagesRes.message === "file does not exist") {
      // אם הקובץ לא קיים, צור אותו עם כל ההודעות הלא נקראות
      await fetch(
        `https://www.call2all.co.il/ym/api/UploadTextFile?token=${authToken}&what=ivr2:YemotSMSInboxReadedMessages.ini&contents=${JSON.stringify(allUnreadMessages)}`
      );
    } else {
      // אם הקובץ קיים, הוסף את ההודעות החדשות
      const readedMessagesData = readedMessagesRes.contents;
      readedMessages = JSON.parse(readedMessagesData);
      readedMessages = readedMessages.concat(allUnreadMessages);

      // עדכן את הקובץ עם כל ההודעות הנקראות
      await fetch(`https://www.call2all.co.il/ym/api/UploadTextFile`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          token: authToken,
          what: 'ivr2:YemotSMSInboxReadedMessages.ini',
          contents: JSON.stringify(readedMessages)
        })
      });
    }

    // עדכן את כל השיחות מקומית - אפס את מונה ההודעות הלא נקראות
    conversations.value = conversations.value.map(conversation => ({
      ...conversation,
      unreadCount: 0,
      messages: conversation.messages.map(message => ({
        ...message,
        read: message.type === 'incoming' ? true : message.read
      }))
    }));

    // עדכן את השיחה הנבחרת אם קיימת
    if (selectedConversation.value) {
      selectedConversation.value = {
        ...selectedConversation.value,
        unreadCount: 0,
        messages: selectedConversation.value.messages.map(message => ({
          ...message,
          read: message.type === 'incoming' ? true : message.read
        }))
      };
    }

    console.log(`Marked ${allUnreadMessages.length} messages as read`);
    
  } catch (error) {
    console.error('Error marking all messages as read:', error);
    alert('שגיאה בסימון ההודעות כנקראו');
  }
}

const handleLogoutRequest = () => {
  logoutDialogVisible.value = true;
};

const handleLogoutConfirm = () => {
  logoutDialogVisible.value = false;
  emit('logout');
};

const handleLogoutCancel = () => {
  logoutDialogVisible.value = false;
};

// Initialize and start periodic checks
const init = async () => {
  try {
    console.log('Checking Google auth status during initialization...');
    const status = await checkGoogleAuthStatus();
    googleAuthStatus.value = status;
    console.log('Initial Google auth status:', status);

    window.dispatchEvent(new CustomEvent('googleAuthStatusUpdated'));
  } catch (error) {
    console.error('Error checking Google auth status during init:', error);
  }

  await getMessages();
  setInterval(checkNewMessages, 5000);
};

// Start the application
init();

// Listen for authentication status changes
window.addEventListener('googleAuthStatusChanged', async () => {
  console.log('Google auth status changed, refreshing data...');
  await getMessages();
});
</script>
</file>

<file path="src/components/NewMessageDialog.vue">
<template>
  <transition name="fade">
    <div 
      v-if="visible" 
      @click="handleBackdropClick"
      class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-50 p-4"
      style="backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">

      <div 
        class="bg-white p-6 rounded-xl shadow-xl w-full max-w-md" 
        @click.stop 
        style="transform-origin: center">
        
        <!-- Header -->
        <div class="flex justify-between items-center mb-5">
          <h3 class="text-xl font-bold text-gray-800">שלח הודעה חדשה</h3>
          <button 
            @click="hasFormData && !loading ? showConfirmDialog = true : handleCancel()" 
            class="p-1.5 rounded-full hover:bg-gray-100 text-gray-500 transition-colors">
            <XMarkIcon class="w-5 h-5" />
          </button>
        </div>

        <!-- Error message -->
        <div v-if="error" class="mb-4 p-3 bg-red-50 border border-red-200 text-red-700 rounded-lg text-sm">
          {{ error }}
        </div>

        <!-- Form -->
        <form @submit.prevent="handleSend" class="space-y-4">
          <!-- Phone Number Input -->
          <label 
            for="phone"
            class="relative block overflow-hidden rounded-lg border border-gray-200 px-3 pt-3 shadow-sm focus-within:border-indigo-600 focus-within:ring-1 focus-within:ring-indigo-600 transition-colors bg-white">
            <input 
              v-model="phoneNumber" 
              type="text" 
              id="phone" 
              placeholder="מספר הטלפון של הנמען"
              :autofocus="shouldFocus"
              required
              class="peer h-10 w-full border-none bg-transparent p-0 placeholder-transparent focus:placeholder-gray-400 focus:outline-none focus:ring-0 sm:text-sm text-gray-900"
              dir="rtl" />
            <span
              class="absolute start-3 top-3 -translate-y-1/2 text-xs text-gray-500 transition-all peer-placeholder-shown:top-1/2 peer-placeholder-shown:text-sm peer-focus:top-3 peer-focus:text-xs">
              מספר טלפון
            </span>
          </label>

          <!-- Message Input -->
          <label 
            for="message"
            class="relative block overflow-hidden rounded-lg border border-gray-200 px-3 pt-3 shadow-sm focus-within:border-indigo-600 focus-within:ring-1 focus-within:ring-indigo-600 transition-colors bg-white">
            <textarea 
              v-model="messageText" 
              id="message" 
              placeholder="הודעה"
              required
              class="peer h-32 w-full border-none bg-transparent p-0 pt-2 placeholder-transparent focus:placeholder-gray-400 focus:outline-none focus:ring-0 sm:text-sm text-gray-900 resize-none"
              dir="rtl"></textarea>
            <span
              class="absolute start-3 top-1 text-xs text-gray-500 transition-all peer-placeholder-shown:top-3 peer-placeholder-shown:text-sm peer-focus:top-1 peer-focus:text-xs">
              הודעה
            </span>
          </label>

          <!-- Send Button -->
          <button 
            type="submit"
            :disabled="loading || !phoneNumber || !messageText" 
            :class="[
              loading || !phoneNumber || !messageText ? 'bg-opacity-70 cursor-not-allowed' : 'hover:bg-indigo-500',
              'mt-2 transition-all w-full px-4 py-3 text-white bg-indigo-600 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 font-medium'
            ]">
            <span v-if="!loading">שלח הודעה</span>
            <span v-else class="flex justify-center items-center">
              <svg class="animate-spin -mr-1 ml-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              שולח הודעה...
            </span>
          </button>
        </form>
      </div>
    </div>
  </transition>

  <!-- Confirmation Dialog -->
  <transition name="fade">
    <div 
      v-if="showConfirmDialog"
      class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-[60] p-4"
      style="backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">
      
      <div 
        class="bg-white rounded-2xl shadow-2xl w-full max-w-sm transform transition-all" 
        @click.stop>
        
        <!-- Header -->
        <div class="p-6 text-center border-b border-gray-100">
          <div class="w-12 h-12 bg-amber-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg class="h-6 w-6 text-amber-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
            </svg>
          </div>
          
          <h3 class="text-lg font-bold text-gray-900 mb-2">
            שמירת השינויים
          </h3>
          
          <p class="text-gray-600 text-sm">
            יש לך נתונים שלא נשמרו. האם אתה בטוח שברצונך לסגור את החלון?
          </p>
        </div>

        <!-- Actions -->
        <div class="flex gap-3 p-6 bg-gray-50 rounded-b-2xl">
          <button 
            @click="cancelDiscard"
            class="flex-1 px-4 py-3 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors font-medium">
            המשך עריכה
          </button>
          
          <button 
            @click="confirmDiscard"
            class="flex-1 px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors font-medium">
            סגור בלי לשמור
          </button>
        </div>
      </div>
    </div>
  </transition>
</template>

<script setup>
import { ref, watch, nextTick, computed } from 'vue';
import { XMarkIcon } from '@heroicons/vue/24/outline';
import { getAuthToken } from '../utils/auth.js';

const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  shouldFocus: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['success', 'cancel', 'error']);

const phoneNumber = ref('');
const messageText = ref('');
const loading = ref(false);
const error = ref('');
const showConfirmDialog = ref(false);

// Reset form when dialog becomes visible
watch(() => props.visible, (newVisible) => {
  if (newVisible) {
    resetForm();
    nextTick(() => {
      if (props.shouldFocus) {
        document.getElementById('phone')?.focus();
      }
    });
  }
});

// Check if form has data
const hasFormData = computed(() => {
  return phoneNumber.value.trim() || messageText.value.trim();
});

const resetForm = () => {
  phoneNumber.value = '';
  messageText.value = '';
  loading.value = false;
  error.value = '';
  showConfirmDialog.value = false;
};

const handleBackdropClick = () => {
  if (hasFormData.value && !loading.value) {
    showConfirmDialog.value = true;
  } else {
    handleCancel();
  }
};

const handleCancel = () => {
  resetForm();
  emit('cancel');
};

const confirmDiscard = () => {
  showConfirmDialog.value = false;
  handleCancel();
};

const cancelDiscard = () => {
  showConfirmDialog.value = false;
};

const handleSend = async () => {
  loading.value = true;
  error.value = '';

  if (!phoneNumber.value || !messageText.value) {
    error.value = 'כל השדות הינם שדות חובה!';
    loading.value = false;
    return;
  }

  try {
    const authToken = await getAuthToken();
    if (!authToken) {
      error.value = 'שגיאה: לא נמצא טוקן אימות';
      loading.value = false;
      return;
    }

    const response = await fetch(
      `https://www.call2all.co.il/ym/api/SendSms?token=${authToken}&phones=${phoneNumber.value}&message=${messageText.value}`
    );

    const data = await response.json();

    if (data.responseStatus === 'OK') {
      resetForm();
      emit('success', {
        phone: phoneNumber.value,
        message: messageText.value
      });
    } else {
      error.value = 'שגיאה בשליחת ההודעה: ' + data.message;
      loading.value = false;
    }
  } catch (err) {
    error.value = 'שגיאה בשליחת ההודעה. אנא נסה שוב מאוחר יותר.';
    console.error('Send message error:', err);
    loading.value = false;
  }
};
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
</file>

<file path="src/services/encryption.service.js">
/**
 * Enhanced Encryption Service
 * Handles secure encryption and decryption of login credentials
 * Uses device-specific keys and stronger encryption algorithms
 */

/**
 * Generate a device-specific fingerprint for encryption key derivation
 * @returns {Promise<string>} - Unique device fingerprint
 */
async function generateDeviceFingerprint() {
    const components = [];

    components.push(`${screen.width}x${screen.height}x${screen.colorDepth}`);
    components.push(Intl.DateTimeFormat().resolvedOptions().timeZone);
    components.push(navigator.language);

    if (navigator.deviceMemory) {
        components.push(navigator.deviceMemory.toString());
    }

    const fingerprint = components.join('|');

    return await hashString(fingerprint);
}

/**
 * Hash a string using SHA-256
 * @param {string} str - String to hash
 * @returns {Promise<string>} - Hex encoded hash
 */
async function hashString(str) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Derive encryption key from device fingerprint and additional entropy
 * @param {string} fingerprint - Device fingerprint
 * @param {string} salt - Additional salt for key derivation
 * @returns {Promise<CryptoKey>} - Derived encryption key
 */
async function deriveEncryptionKey(fingerprint, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        encoder.encode(fingerprint + salt),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
    );

    return await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: encoder.encode(salt),
            iterations: 100000,
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
}

/**
 * Generate a random salt
 * @returns {string} - Base64 encoded random salt
 */
function generateSalt() {
    const salt = new Uint8Array(16);
    crypto.getRandomValues(salt);
    return btoa(String.fromCharCode(...salt));
}

/**
 * Encrypt data using AES-GCM
 * @param {string} data - Data to encrypt
 * @param {CryptoKey} key - Encryption key
 * @returns {Promise<Object>} - Encrypted data with IV
 */
async function encryptData(data, key) {
    const encoder = new TextEncoder();
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for GCM

    const encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encoder.encode(data)
    );

    return {
        encrypted: btoa(String.fromCharCode(...new Uint8Array(encryptedBuffer))),
        iv: btoa(String.fromCharCode(...iv))
    };
}

/**
 * Decrypt data using AES-GCM
 * @param {string} encryptedData - Base64 encoded encrypted data
 * @param {string} ivString - Base64 encoded IV
 * @param {CryptoKey} key - Decryption key
 * @returns {Promise<string>} - Decrypted data
 */
async function decryptData(encryptedData, ivString, key) {
    const encrypted = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
    const iv = Uint8Array.from(atob(ivString), c => c.charCodeAt(0));

    const decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encrypted
    );

    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
}

/**
 * Encrypt user credentials with device-specific key
 * @param {string} username - Username
 * @param {string} password - Password
 * @returns {Promise<string>} - Encrypted credentials as JSON string
 */
export async function encryptCredentials(username, password) {
    try {
        const deviceFingerprint = await generateDeviceFingerprint();
        const salt = generateSalt();
        const key = await deriveEncryptionKey(deviceFingerprint, salt);

        const credentials = {
            username: username,
            password: password,
            timestamp: Date.now()
        };

        const jsonString = JSON.stringify(credentials);
        const encryptedData = await encryptData(jsonString, key);

        return JSON.stringify({
            salt: salt,
            encrypted: encryptedData.encrypted,
            iv: encryptedData.iv
        });
    } catch (error) {
        console.error('Error encrypting credentials:', error);
        throw error;
    }
}

/**
 * Decrypt user credentials using device-specific key
 * @param {string} encryptedCredentials - Encrypted credentials JSON string
 * @returns {Promise<Object|null>} - Decrypted credentials object or null on error
 */
export async function decryptCredentials(encryptedCredentials) {
    if (!encryptedCredentials) {
        return null;
    }

    try {
        const encryptedData = JSON.parse(encryptedCredentials);

        const deviceFingerprint = await generateDeviceFingerprint();
        const key = await deriveEncryptionKey(deviceFingerprint, encryptedData.salt);

        const decryptedString = await decryptData(
            encryptedData.encrypted,
            encryptedData.iv,
            key
        );

        const credentials = JSON.parse(decryptedString);

        // Validate credentials structure
        if (!credentials.username || !credentials.password) {
            console.error('Invalid credentials structure');
            return null;
        }

        // Check if credentials are too old (30 days)
        const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1000;
        if (credentials.timestamp && (Date.now() - credentials.timestamp) > thirtyDaysInMs) {
            console.warn('Credentials are older than 30 days, consider re-authentication');
            // Don't return null, just warn - let the user decide
        }

        return {
            username: credentials.username,
            password: credentials.password,
            timestamp: credentials.timestamp
        };

    } catch (error) {
        console.error('Error decrypting credentials:', error);
        // If decryption fails, it might be due to device change or corrupted data
        clearCredentials();
        return null;
    }
}

/**
 * Check if valid credentials exist in storage
 * @returns {Promise<boolean>} - True if valid credentials exist
 */
export async function hasValidCredentials() {
    try {
        const encryptedCredentials = localStorage.getItem('credentials');
        if (!encryptedCredentials) {
            return false;
        }

        const credentials = await decryptCredentials(encryptedCredentials);
        return credentials !== null;
    } catch (error) {
        console.error('Error checking valid credentials:', error);
        return false;
    }
}

/**
 * Get saved credentials from storage
 * @returns {Promise<Object|null>} - Credentials object or null
 */
export async function getSavedCredentials() {
    try {
        const encryptedCredentials = localStorage.getItem('credentials');
        if (!encryptedCredentials) {
            return null;
        }

        return await decryptCredentials(encryptedCredentials);
    } catch (error) {
        console.error('Error getting saved credentials:', error);
        return null;
    }
}

/**
 * Save encrypted credentials to storage
 * @param {string} username - Username
 * @param {string} password - Password
 * @returns {Promise<boolean>} - True if save was successful
 */
export async function saveCredentials(username, password) {
    try {
        const encryptedCredentials = await encryptCredentials(username, password);
        localStorage.setItem('credentials', encryptedCredentials);
        console.log('Credentials saved successfully');
        return true;
    } catch (error) {
        console.error('Error saving credentials:', error);
        return false;
    }
}

/**
 * Clear all stored credentials
 */
export function clearCredentials() {
    localStorage.removeItem('credentials');
    localStorage.removeItem('app_username'); // נקה גם את השם המשתמש הישן
    console.log('Credentials cleared from localStorage');
}

/**
 * Update stored password while keeping existing username
 * @param {string} newPassword - New password
 * @returns {Promise<boolean>} - True if update was successful
 */
export async function updatePassword(newPassword) {
    try {
        const credentials = await getSavedCredentials();
        if (!credentials) {
            console.error('No existing credentials to update');
            return false;
        }

        return await saveCredentials(credentials.username, newPassword);
    } catch (error) {
        console.error('Error updating password:', error);
        return false;
    }
}

/**
 * Validate credentials against the server
 * @returns {Promise<boolean>} - True if credentials are valid
 */
export async function validateCredentials() {
    try {
        const credentials = await getSavedCredentials();
        if (!credentials) {
            return false;
        }

        const response = await fetch(
            `https://www.call2all.co.il/ym/api/GetSession?token=${credentials.username}:${credentials.password}`
        );
        const data = await response.json();

        return data.responseStatus === 'OK';
    } catch (error) {
        console.error('Error validating credentials:', error);
        return false;
    }
}

/**
 * Get device fingerprint (for debugging purposes)
 * @returns {Promise<string>} - Device fingerprint
 */
export async function getDeviceFingerprint() {
    return await generateDeviceFingerprint();
}
</file>

<file path="src/utils/auth.js">
// קובץ: src/utils/auth.js
// פונקציות עזר לאימות שיכולות לשמש בכל הרכיבים

import { getSavedCredentials } from '../services/encryption.service';

/**
 * קבל טוקן אימות בטוח
 * @returns {string|null} - טוקן האימות או null אם לא נמצא
 */
export async function getAuthToken() {
    const credentials = await getSavedCredentials();
    if (!credentials) {
        console.error('No valid credentials found');
        return null;
    }
    return `${credentials.username}:${credentials.password}`;
}

/**
 * שלח בקשה מאומתת ל-API
 * @param {string} endpoint - נקודת הקצה ב-API
 * @param {Object} options - אפשרויות נוספות לבקשה
 * @returns {Promise<Response>} - תגובת השרת
 */
export async function authenticatedFetch(endpoint, options = {}) {
    const authToken = getAuthToken();
    if (!authToken) {
        throw new Error('No authentication token available');
    }

    // הוסף את הטוקן ל-URL אם זה GET request
    if (!options.method || options.method === 'GET') {
        const separator = endpoint.includes('?') ? '&' : '?';
        endpoint = `${endpoint}${separator}token=${authToken}`;
    }

    return fetch(endpoint, options);
}

/**
 * בדוק אם המשתמש מחובר
 * @returns {boolean} - true אם המשתמש מחובר
 */
export function isAuthenticated() {
    return getAuthToken() !== null;
}

/**
 * קבל שם המשתמש הנוכחי
 * @returns {string|null} - שם המשתמש או null
 */
export function getCurrentUsername() {
    const credentials = getSavedCredentials();
    return credentials ? credentials.username : null;
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/vue.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
</file>

<file path="src/components/PrivacyPolicy.vue">
<template>
    <transition name="fade">
        <div v-if="privacyPolicyVisible"
            class="fixed inset-0 bg-black bg-opacity-40 flex justify-center items-center z-50 p-4"
            @click="closePrivacyPolicy">

            <div class="bg-white rounded-3xl shadow-xl w-full max-w-4xl max-h-[85vh] flex flex-col" @click.stop>
                <!-- Header -->
                <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-6 relative flex-shrink-0 rounded-t-2xl">
                    <button @click="closePrivacyPolicy"
                        class="absolute top-4 left-4 text-gray-300 hover:text-white p-1">
                        <X />
                    </button>
                    <div class="text-center">
                        <h1 class="text-2xl font-semibold mb-1">מדיניות פרטיות</h1>
                        <p class="text-gray-300 text-sm">{{ appName }} - תצוגת שיחות</p>
                    </div>
                </div>

                <!-- Loading State -->
                <div v-if="loading" class="flex-1 flex items-center justify-center p-8">
                    <div class="text-center">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-2"></div>
                        <p class="text-gray-600">טוען מדיניות פרטיות...</p>
                    </div>
                </div>

                <!-- Error State -->
                <div v-else-if="error" class="flex-1 flex items-center justify-center p-8">
                    <div class="text-center">
                        <p class="text-red-600 mb-2">שגיאה בטעינת מדיניות הפרטיות</p>
                        <button @click="loadPrivacyPolicy" 
                                class="text-indigo-600 hover:text-indigo-800 underline">
                            נסה שוב
                        </button>
                    </div>
                </div>

                <!-- Content -->
                <div v-else class="flex-1 overflow-y-auto p-6">
                    <div class="markdown-content" v-html="markdownContent"></div>
                </div>

                <!-- Footer -->
                <div class="bg-gray-50 px-6 py-4 border-t flex justify-between items-center flex-shrink-0 rounded-b-2xl">
                    <span class="text-sm text-gray-500">{{ fullAppTitle }}</span>
                    <button @click="closePrivacyPolicy"
                        class="bg-gradient-to-r from-indigo-600 to-purple-600 hover:bg-indigo-700 text-white px-4 py-2 rounded text-sm font-medium transition-colors">
                        סגור
                    </button>
                </div>
            </div>
        </div>
    </transition>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { marked } from 'marked';
import { X } from 'lucide-vue-next';

const privacyPolicyVisible = ref(false);
const markdownContent = ref('');
const loading = ref(false);
const error = ref(false);

const appName = import.meta.env.VITE_APP_NAME;
const version = import.meta.env.VITE_VERSION || '0.0.0';
const fullAppTitle = `${appName} v${version}`;

const parseMarkdown = (markdown) => {
    return marked(markdown, {
        breaks: true,
        gfm: true
    });
};

const wrapListItems = (html) => {
    return html.replace(/(<li[^>]*>.*?<\/li>(?:\s*<li[^>]*>.*?<\/li>)*)/gs, 
        '<ul class="space-y-2 mb-6 pr-4">$1</ul>');
};

const wrapParagraphs = (html) => {
    // עוטף תוכן שאינו כותרות או רשימות בתגי p
    const lines = html.split('\n');
    let result = '';
    let inParagraph = false;
    
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        
        if (line.startsWith('<h') || line.startsWith('<ul>') || line.startsWith('</ul>')) {
            if (inParagraph) {
                result += '</p>\n';
                inParagraph = false;
            }
            result += line + '\n';
        } else if (line.startsWith('<li>')) {
            result += line + '\n';
        } else {
            if (!inParagraph) {
                result += '<p class="text-gray-700 leading-relaxed mb-4">';
                inParagraph = true;
            }
            result += line + ' ';
        }
    }
    
    if (inParagraph) {
        result += '</p>\n';
    }
    
    return result;
};

const loadPrivacyPolicy = async () => {
    loading.value = true;
    error.value = false;
    
    try {
        // טען את קובץ המרקדאון דינמית
        const markdownModule = await import('/privacy-policy.md?raw');
        const markdown = markdownModule.default;
        
        // המר את המרקדאון ל-HTML
        let html = parseMarkdown(markdown);
        html = wrapParagraphs(html);
        html = wrapListItems(html);
        
        markdownContent.value = html;
    } catch (err) {
        console.error('Error loading privacy policy:', err);
        error.value = true;
        // fallback content
        markdownContent.value = `
            <h1 class="text-2xl font-bold text-gray-900 mb-6">מדיניות פרטיות</h1>
            <p class="text-gray-700 leading-relaxed mb-4">
                שגיאה בטעינת מדיניות הפרטיות. אנא נסה שוב מאוחר יותר או פנה אלינו בדוא"ל cs@abaye.co
            </p>
        `;
    } finally {
        loading.value = false;
    }
};

const checkPrivacyPolicyPath = () => {
    const currentPath = window.location.pathname;
    return currentPath.endsWith('/privacy-policy') || currentPath.includes('/privacy-policy');
};

const updatePrivacyPolicyVisibility = async () => {
    const shouldShow = checkPrivacyPolicyPath();
    privacyPolicyVisible.value = shouldShow;
    
    if (shouldShow && !markdownContent.value) {
        await loadPrivacyPolicy();
    }
};

const closePrivacyPolicy = () => {
    privacyPolicyVisible.value = false;
    const currentPath = window.location.pathname;
    const newPath = currentPath.replace(/\/privacy-policy$/, '');
    window.history.pushState({}, document.title, newPath || '/');
};

const handlePopState = () => {
    updatePrivacyPolicyVisibility();
};

const openPrivacyPolicy = async () => {
    const currentPath = window.location.pathname;
    const newPath = currentPath.endsWith('/') ?
        currentPath + 'privacy-policy' :
        currentPath + '/privacy-policy';

    window.history.pushState({}, 'מדיניות פרטיות', newPath);
    await updatePrivacyPolicyVisibility();
};

onMounted(() => {
    updatePrivacyPolicyVisibility();
    window.addEventListener('popstate', handlePopState);
    window.openPrivacyPolicy = openPrivacyPolicy;
});

onUnmounted(() => {
    window.removeEventListener('popstate', handlePopState);
    delete window.openPrivacyPolicy;
});
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}
</style>
</file>

<file path="src/services/google.service.js">
/**
 * Google Contacts Integration Service
 * Handles authentication, token management, and contacts retrieval
 */

import { getAuthToken } from "../utils/auth";

// Constants for Google authentication
const CLIENT_ID = '293453062070-ne2pf11bn93mjr9mka97i484rb150vlt.apps.googleusercontent.com';
// עדכון הסקופים לכלול גישה לאימייל
const SCOPES = 'https://www.googleapis.com/auth/contacts.readonly https://www.googleapis.com/auth/userinfo.email';
const DISCOVERY_DOC = 'https://people.googleapis.com/$discovery/rest?version=v1';

/**
 * Get Google contacts if authenticated
 * @returns {Promise<Object>} Authentication status, contacts, and user data
 */
export async function getGoogleContacts() {
  try {
    console.log('Getting Google contacts...');
    
    // Check if GAPI is available
    if (!window.gapi) {
      console.log('GAPI not loaded, loading now...');
      await loadGoogleApi();
    }

    // Check for stored token
    const userData = await getGoogleTokenData();
    console.log('User token data retrieved:', userData ? 'Found' : 'Not found');

    if (userData && userData.token &&
      userData.tokenExpiry && new Date(userData.tokenExpiry).getTime() > Date.now()) {
      console.log('Valid token found, expiry:', new Date(userData.tokenExpiry).toLocaleString());
      
      // We have a valid token, use it
      gapi.client.setToken({ access_token: userData.token });

      // Fetch contacts
      console.log('Fetching contacts with token...');
      const contacts = await fetchGoogleContacts(userData.token);
      console.log(`Retrieved ${contacts.length} contacts`);

      return {
        isAuthenticated: true,
        contacts: contacts,
        userData: {
          email: userData.userEmail,
          tokenExpiry: new Date(userData.tokenExpiry).toLocaleString()
        }
      };
    } else {
      if (userData) {
        console.log('Token expired or invalid, expiry:', 
                   userData.tokenExpiry ? new Date(userData.tokenExpiry).toLocaleString() : 'none');
      } else {
        console.log('No token data found');
      }
      
      // Need to authenticate - check if GSI is loaded
      if (!window.google || !window.google.accounts) {
        console.log('Google Identity Services not loaded, loading now...');
        await loadGoogleIdentityServices();
      }

      // Return authentication status
      return {
        isAuthenticated: false,
        contacts: [],
        userData: null
      };
    }
  } catch (error) {
    console.error('Error in getGoogleContacts:', error);
    return {
      isAuthenticated: false,
      contacts: [],
      userData: null,
      error: error.message
    };
  }
}

/**
 * Load Google API script
 * @returns {Promise<void>}
 */
export function loadGoogleApi() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://apis.google.com/js/api.js';
    script.async = true;
    script.defer = true;

    script.onload = () => {
      console.log('GAPI loaded successfully');

      // Initialize GAPI
      gapi.load('client', async () => {
        try {
          await gapi.client.init({
            discoveryDocs: ['https://people.googleapis.com/$discovery/rest?version=v1'],
          });
          console.log('GAPI client initialized');
          resolve();
        } catch (error) {
          console.error('Error initializing GAPI client:', error);
          reject(error);
        }
      });
    };

    script.onerror = (error) => {
      console.error('Error loading GAPI:', error);
      reject(new Error('Failed to load Google API'));
    };

    document.head.appendChild(script);
  });
}

/**
 * Load Google Identity Services
 * @returns {Promise<void>}
 */
export function loadGoogleIdentityServices() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.async = true;
    script.defer = true;

    script.onload = () => {
      console.log('Google Identity Services loaded successfully');
      resolve();
    };

    script.onerror = (error) => {
      console.error('Error loading Google Identity Services:', error);
      reject(new Error('Failed to load Google Identity Services'));
    };

    document.head.appendChild(script);
  });
}

/**
 * Initiate Google login flow
 * @returns {Promise<boolean>} Success status
 */
export async function initiateGoogleLogin() {
  try {
    // Ensure Google APIs are loaded
    if (!window.gapi) await loadGoogleApi();
    if (!window.google || !window.google.accounts) await loadGoogleIdentityServices();

    return new Promise((resolve) => {
      // Setup token client
      const tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES, // כולל כעת גם הרשאות אימייל
        prompt: 'consent', // תמיד נבקש הסכמה מחדש למקרה של שגיאות 403
        callback: async (response) => {
          if (response.error) {
            console.error('Authentication error:', response.error);
            resolve(false);
            return;
          }

          // Successfully received token
          const token = response.access_token;
          const tokenExpiry = Date.now() + (response.expires_in * 1000);

          // נרשום מידע מלא על התהליך
          console.log('Received token:', token.substring(0, 10) + '...');
          console.log('Token expiry:', new Date(tokenExpiry).toLocaleString());

          try {
            // Set token in GAPI
            gapi.client.setToken({ access_token: token });

            // Get user email with additional logging
            console.log('Fetching user info...');
            const userInfo = await fetchUserInfo(token);
            console.log('User info received:', userInfo);

            if (!userInfo.email) {
              console.error('Failed to get user email despite successful authentication');
            }

            // Save token data
            console.log('Saving token data...');
            const success = await saveGoogleTokenData({
              token: token,
              tokenExpiry: new Date(tokenExpiry).toISOString(),
              userEmail: userInfo.email
            });
            
            if (success) {
              console.log('Token data saved successfully');
            } else {
              console.error('Failed to save token data');
            }

            resolve(success);
          } catch (err) {
            console.error('Error in token processing:', err);
            resolve(false);
          }
        }
      });

      // Request token with explicit prompt to handle 403 errors
      tokenClient.requestAccessToken();
    });
  } catch (error) {
    console.error('Error initiating Google login:', error);
    return false;
  }
}

/**
 * Fetch user info from Google
 * @param {string} token Access token
 * @returns {Promise<Object>} User info
 */
export async function fetchUserInfo(token) {
  try {
    console.log('Fetching user info with token...');
    
    // נסה קודם כל בשיטה ישירה יותר
    try {
      const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (userInfoResponse.ok) {
        const userInfo = await userInfoResponse.json();
        console.log('User info from userinfo endpoint:', userInfo);
        if (userInfo.email) {
          return { email: userInfo.email };
        }
      } else {
        console.warn('Failed to get user info from userinfo endpoint:', 
                   await userInfoResponse.text());
      }
    } catch (userInfoError) {
      console.error('Error fetching from userinfo endpoint:', userInfoError);
    }
    
    // אם לא הצלחנו, ננסה עם People API
    const response = await gapi.client.request({
      path: 'https://people.googleapis.com/v1/people/me',
      method: 'GET',
      params: {
        personFields: 'emailAddresses,names',
      },
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    console.log('People API response:', response);
    
    let email = '';
    if (response.result && response.result.emailAddresses && response.result.emailAddresses.length > 0) {
      email = response.result.emailAddresses[0].value;
      console.log('Found email in people API:', email);
    }

    return { email };
  } catch (error) {
    console.error('Error fetching user info:', error);
    return { email: '' };
  }
}

/**
 * Fetch Google contacts using the token
 * @param {string} token Access token
 * @returns {Promise<Array>} Formatted contacts
 */
export async function fetchGoogleContacts(token) {
  try {
    // Make the request to Google People API with explicit token in headers
    const response = await gapi.client.request({
      path: 'https://people.googleapis.com/v1/people/me/connections',
      method: 'GET',
      params: {
        personFields: 'names,phoneNumbers',
        pageSize: 1000
      },
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    // Process the results
    let formattedContacts = [];

    if (response.result && response.result.connections) {
      console.log(`Processing ${response.result.connections.length} raw contacts`);
      
      // Extract and format contacts with phone numbers
      formattedContacts = response.result.connections
        .filter(person => person.phoneNumbers && person.phoneNumbers.length > 0)
        .map(person => {
          // Format phone number - keep only digits and ensure it starts with 0 if Israeli number
          let phone = person.phoneNumbers[0].value.replace(/\D/g, '');
          if (phone.startsWith('972')) {
            phone = '0' + phone.substring(3);
          }

          return {
            name: person.names && person.names.length > 0 ? person.names[0].displayName : 'ללא שם',
            phone: phone
          };
        });
      
      console.log(`Formatted ${formattedContacts.length} contacts with phone numbers`);
    } else {
      console.log('No connections found in the response');
    }

    return formattedContacts;
  } catch (error) {
    console.error('Error fetching Google contacts:', error);

    // Check if token is invalid
    if (error.status === 401 || (error.result && error.result.error && error.result.error.code === 401)) {
      // Token expired - remove it
      console.log('Token expired (401), removing token data');
      await deleteGoogleTokenData();
    } else if (error.status === 403 || (error.result && error.result.error && error.result.error.code === 403)) {
      // Permission issue
      console.log('Permission denied (403), removing token and requesting a new one');
      await deleteGoogleTokenData();
    }

    return [];
  }
}

/**
 * Save Google token data to server
 * @param {Object} userData User data to save
 * @returns {Promise<boolean>} Success status
 */
export async function saveGoogleTokenData(userData) {
  try {
    console.log('Saving Google token data');

    // Convert data to JSON string
    const dataAsString = JSON.stringify(userData);

    // Upload to server
    const response = await fetch(`https://www.call2all.co.il/ym/api/UploadTextFile`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        token: `${localStorage.getItem('username')}:${localStorage.getItem('password')}`,
        what: 'ivr2:GoogleToken.txt',
        contents: dataAsString
      })
    });

    if (!response.ok) {
      throw new Error(`Error saving token data: ${response.status}`);
    }

    console.log('Google token data saved successfully');
    return true;
  } catch (error) {
    console.error('Error saving Google token data:', error);
    return false;
  }
}

/**
 * Get Google token data from server
 * @returns {Promise<Object|null>} User data or null if not found
 */
export async function getGoogleTokenData() {
  try {
    console.log('Retrieving Google token data');

    // Get data from server
    const response = await fetch(
      `https://www.call2all.co.il/ym/api/GetTextFile?token=${await getAuthToken()}&what=ivr2:GoogleToken.txt`
    );

    if (!response.ok) {
      if (response.status === 404) {
        console.log('No Google token data found');
        return null;
      }
      throw new Error(`Error retrieving token data: ${response.status}`);
    }

    const responseData = await response.json();

    // Parse token data
    if (responseData && responseData.contents) {
      try {
        const userData = JSON.parse(responseData.contents);
        console.log('Google token data retrieved successfully');
        return userData;
      } catch (parseError) {
        console.error('Error parsing JSON data:', parseError);
        return null;
      }
    }

    console.log('Invalid token data received');
    return null;
  } catch (error) {
    console.error('Error retrieving Google token data:', error);
    return null;
  }
}

/**
 * Delete Google token data from server
 * @returns {Promise<boolean>} Success status
 */
export async function deleteGoogleTokenData() {
  try {
    console.log('Deleting Google token data');

    // Upload empty file to replace existing one
    await fetch(`https://www.call2all.co.il/ym/api/UploadTextFile`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        token: `${localStorage.getItem('username')}:${localStorage.getItem('password')}`,
        what: 'ivr2:GoogleToken.txt',
        contents: ''
      })
    });

    console.log('Google token data deleted successfully');
    return true;
  } catch (error) {
    console.error('Error deleting Google token data:', error);
    return false;
  }
}

/**
 * Log out from Google
 * @returns {Promise<boolean>} Success status
 */
export async function logoutFromGoogle() {
  try {
    console.log('Logging out from Google');

    // Revoke token if Google API is available
    if (window.google && google.accounts && google.accounts.oauth2) {
      const userData = await getGoogleTokenData();
      if (userData && userData.token) {
        google.accounts.oauth2.revoke(userData.token, () => {
          console.log('Token revoked successfully');
        });
      }
    }

    // Clear GAPI token
    if (window.gapi && gapi.client) {
      gapi.client.setToken(null);
    }

    // Delete token data from server
    await deleteGoogleTokenData();

    console.log('Google logout completed');
    return true;
  } catch (error) {
    console.error('Error logging out from Google:', error);
    return false;
  }
}

/**
 * Check Google authentication status
 * @returns {Promise<Object>} Authentication status
 */
export async function checkGoogleAuthStatus() {
  try {
    console.log('Checking Google authentication status');
    
    // בדוק אם יש טוקן שמור לפני שמנסים להתחבר ל-API
    const userData = await getGoogleTokenData();
    
    if (userData && userData.token && userData.tokenExpiry) {
      const isTokenValid = new Date(userData.tokenExpiry).getTime() > Date.now();
      console.log('Found token, valid:', isTokenValid, 'expiry:', new Date(userData.tokenExpiry).toLocaleString());
      
      if (isTokenValid) {
        // אם הטוקן תקף, טען את ה-API ונסה לקבל אנשי קשר
        if (!window.gapi) await loadGoogleApi();
        
        // הגדר את הטוקן ב-GAPI
        gapi.client.setToken({ access_token: userData.token });
        
        // נסה לקבל אנשי קשר כדי לוודא שהטוקן עובד
        try {
          const contacts = await fetchGoogleContacts(userData.token);
          console.log(`Retrieved ${contacts.length} contacts during status check`);
          
          return {
            isAuthenticated: true,
            userEmail: userData.userEmail || '',
            contactCount: contacts.length
          };
        } catch (fetchError) {
          console.error('Error fetching contacts during status check:', fetchError);
          // אם יש שגיאה בקבלת אנשי קשר, ייתכן שהטוקן לא תקף למרות התאריך
          if (fetchError.status === 401 || fetchError.status === 403) {
            console.log('Token validation failed despite valid expiry date, removing token');
            await deleteGoogleTokenData();
          }
        }
      } else {
        // הטוקן פג תוקף, מחק אותו
        console.log('Token expired, removing');
        await deleteGoogleTokenData();
      }
    } else {
      console.log('No valid token data found during status check');
    }
    
    // אם הגענו לכאן, המשתמש לא מחובר
    return {
      isAuthenticated: false,
      userEmail: '',
      contactCount: 0
    };
  } catch (error) {
    console.error('Error in checkGoogleAuthStatus:', error);
    return {
      isAuthenticated: false,
      userEmail: '',
      contactCount: 0
    };
  }
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  base: '/inbox',
  plugins: [vue()],
  assetsInclude: ['**/*.md']
})
</file>

<file path="src/main.js">
import { createApp } from 'vue'
import './style.css'
import VueTippy from 'vue-tippy'

import 'tippy.js/dist/tippy.css'
import 'tippy.js/themes/light-border.css'

import App from './App.vue'

createApp(App).use(VueTippy, {
    directive: 'tippy',
    defaultProps: {
        theme: 'light-border',
        arrow: false,
        offest: [0, 10],
        placement: 'bottom'
    }
}).mount('#app')
</file>

<file path="package.json">
{
  "name": "vite-vue-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/vue": "^2.2.0",
    "date-fns": "^4.1.0",
    "lucide-vue-next": "^0.514.0",
    "marked": "^15.0.12",
    "vue": "^3.4.38",
    "vue-tippy": "^6.7.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.1.3",
    "autoprefixer": "^10.4.17",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "vite": "^5.4.2"
  }
}
</file>

<file path="src/style.css">
@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@100..900&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    font-family: "Heebo", sans-serif;
    margin: 0;
    min-height: 100vh;
  }
}

#app {
  height: 100vh;
}

.tippy-box {
  font-size: 12px;
  border-radius: 8px;
  padding: 2px 6px 2px 6px;
  background-color: #000000CC !important;
  color: white !important;
  border: none !important;
}
</file>

<file path="index.html">
<!doctype html>
<html lang="he-IL" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/sms.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google-site-verification" content="984ik5biEZMsGdS3HUa1uu0hXJn_k-CyMUR0_H5F8d8" />
    <title>סמייל פרו - תצוגת שיחות</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="README.md">
# Yemot SMS Inbox

Interface for SMS inbox in Yemot.

[![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/K3K212J8Q7)
</file>

<file path="src/components/ConversationList.vue">
<script setup>
import { format, isToday, isThisYear, differenceInDays } from 'date-fns';
import { he } from 'date-fns/locale';
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';
import {
  FunnelIcon,
  PencilSquareIcon,
  MagnifyingGlassIcon,
  XMarkIcon,
  CheckCircleIcon,
  EllipsisVerticalIcon
} from "@heroicons/vue/24/outline";
import { MessageSquarePlus } from 'lucide-vue-next';

import {
  checkGoogleAuthStatus,
  initiateGoogleLogin,
  logoutFromGoogle
} from '../services/google.service';
import NewMessageDialog from './NewMessageDialog.vue';

const props = defineProps({
  conversations: {
    type: Array,
    default: () => []
  },
  selectedId: {
    type: String,
    default: null
  },
});

const emit = defineEmits(['select', 'refreshMessages', 'filter', 'markAllAsRead']);

const openPrivacyPolicy = () => {
  window.openPrivacyPolicy()
};

const newMessageDialogVisible = ref(false);
const filter = ref(false);
const searchQuery = ref('');
const showActionsMenu = ref(false);

const googleStatus = ref({
  isAuthenticated: false,
  userEmail: '',
  contactCount: 0
});

const toggleActionsMenu = () => {
  showActionsMenu.value = !showActionsMenu.value;
};

// Close menu when clicking outside
const handleClickOutside = (event) => {
  if (!event.target.closest('.actions-menu-container')) {
    showActionsMenu.value = false;
  }
};

const handleGoogleStatusUpdate = async () => {
  console.log('Received googleAuthStatusUpdated event in ConversationList');
  await checkGoogleStatus();
};

onMounted(() => {
  checkGoogleStatus();
  document.addEventListener('click', handleClickOutside);
  window.addEventListener('googleAuthStatusUpdated', handleGoogleStatusUpdate);
  window.addEventListener('googleAuthStatusChanged', handleGoogleStatusUpdate);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
  window.removeEventListener('googleAuthStatusUpdated', handleGoogleStatusUpdate);
  window.removeEventListener('googleAuthStatusChanged', handleGoogleStatusUpdate);
});

// Function to check Google Auth status
async function checkGoogleStatus() {
  try {
    const status = await checkGoogleAuthStatus();
    googleStatus.value = status;
    console.log('Google Auth Status updated in ConversationList:', status);
  } catch (error) {
    console.error('Error checking Google auth status in ConversationList:', error);
  }
}

// Function to handle Google login
async function handleGoogleLogin() {
  console.log('Initiating Google login...');
  try {

    await initiateGoogleLogin();

    let attempts = 0;
    const maxAttempts = 20;

    const checkLoginStatus = async () => {
      attempts++;
      const status = await checkGoogleAuthStatus();
      console.log(`Login status check attempt ${attempts}:`, status);

      if (status.isAuthenticated) {
        googleStatus.value = status;

        emit('refreshMessages');
        return;
      }

      if (attempts < maxAttempts) {
        setTimeout(checkLoginStatus, 500);
      }
    };

    setTimeout(checkLoginStatus, 1000);
  } catch (error) {
    console.error('Error during Google login:', error);
    alert('שגיאה בתהליך ההתחברות לגוגל. אנא נסה שוב.');
  }
}

// Function to handle Google logout
async function handleGoogleLogout() {
  const confirmLogout = confirm('האם אתה בטוח שברצונך להפסיק את הסנכרון עם גוגל?');
  if (!confirmLogout) return;
  console.log('Logging out from Google...');
  await logoutFromGoogle();
  await checkGoogleStatus();
  emit('refreshMessages');
}

const filteredConversations = computed(() => {
  if (!searchQuery.value) return props.conversations;

  const query = searchQuery.value.toLowerCase();
  return props.conversations.filter(conversation =>
    conversation.name.toLowerCase().includes(query) ||
    conversation.lastMessage.message.toLowerCase().includes(query)
  );
});

const formatTime = (date) => {
  const now = new Date();
  const messageDate = new Date(date);

  if (isToday(messageDate)) {
    return format(messageDate, 'HH:mm');
  }

  const daysDifference = differenceInDays(now, messageDate);

  if (daysDifference <= 7) {
    switch (daysDifference) {
      case 0:
        return 'אתמול';
      case 1:
        return 'לפני יומיים';
      default:
        return `לפני ${daysDifference + 1} ימים`;
    }
  }

  if (isThisYear(messageDate)) {
    return format(messageDate, 'd בMMMM', { locale: he });
  }

  return format(messageDate, 'd בMMMM yyyy', { locale: he });
};

const hasUnreadMessages = computed(() => {
  return props.conversations.some(conversation => conversation.unreadCount > 0);
});

// Handle new message dialog events
const handleNewMessageSuccess = (messageData) => {
  newMessageDialogVisible.value = false;
  emit('refreshMessages');
  console.log('הודעה חדשה נשלחה בהצלחה:', messageData);
};

const handleNewMessageCancel = () => {
  newMessageDialogVisible.value = false;
};

const handleNewMessageError = (error) => {
  console.error('שגיאה בשליחת הודעה חדשה:', error);
};

const toggleFilter = () => {
  filter.value = !filter.value;
  emit('filter', filter.value);
};

const markAllAsRead = () => {
  if (confirm('האם אתה בטוח שברצונך לסמן את כל ההודעות כנקראו?')) {
    emit('markAllAsRead');
  }
};

watch(() => props.selectedId, (newVal) => {
  if (newVal) {
    console.log('Selected ID in ConversationList:', newVal);
    console.log('All conversation IDs:', props.conversations.map(c => c.id));
  }
});

onMounted(() => {
  if (props.selectedId) {
    console.log('Initial selectedId:', props.selectedId);
    console.log('Initial conversations:', props.conversations.map(c => c.id));
  }
});
</script>

<template>
  <div :class="[
    selectedId ? 'hidden md:block md:w-96' : 'w-full md:w-96',
    'border-l border-gray-200 h-full overflow-y-auto fixed top-0 right-0 bg-white z-30 transition-all'
  ]">
    <!-- Header -->
    <div
      class="px-5 py-4 sticky top-0 z-10 bg-white backdrop-blur-sm bg-opacity-95 border-b border-gray-100 flex items-center justify-between">
      <h1 class="text-2xl font-bold text-gray-800">
        הודעות
      </h1>
      <div class="flex items-center gap-2">
        <!-- Google Auth Button -->
        <button @click="googleStatus.isAuthenticated ? handleGoogleLogout() : handleGoogleLogin()"
          class="p-1.5 rounded-full border transition-all hover:bg-gray-100 hover:border-gray-300"
          :class="googleStatus.isAuthenticated ? 'border-green-500 bg-green-50 hover:bg-green-50 hover:border-green-500' : 'border-transparent'"
          title="התחבר עם Google לסנכרון אנשי קשר">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" class="w-6 h-6">
            <path fill="#FFC107"
              d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z">
            </path>
            <path fill="#FF3D00"
              d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z">
            </path>
            <path fill="#4CAF50"
              d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z">
            </path>
            <path fill="#1976D2"
              d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z">
            </path>
          </svg>
        </button>

        <!-- Actions Menu -->
        <div v-if="hasUnreadMessages" class="relative actions-menu-container">
          <button @click="toggleActionsMenu"
            class="p-2 rounded-full hover:bg-gray-100 text-gray-600 transition relative"
            :class="{ 'bg-gray-100': showActionsMenu }" title="פעולות נוספות">
            <EllipsisVerticalIcon class="w-5 h-5" />
            <!-- Badge for unread count -->
            <div class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full flex items-center justify-center">
              <span class="text-xs text-white font-medium">
                {{props.conversations.reduce((sum, conv) => sum + conv.unreadCount, 0)}}
              </span>
            </div>
          </button>

          <!-- Dropdown Menu with higher z-index -->
          <transition name="dropdown">
            <div v-if="showActionsMenu"
              class="absolute top-full left-0 mt-1 w-48 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-[100]">
              <button @click="toggleFilter(); showActionsMenu = false"
                class="w-full px-4 py-2 text-right hover:bg-gray-50 flex items-center gap-3 transition-colors"
                :class="{ 'bg-indigo-50 text-indigo-700': filter }">
                <FunnelIcon class="w-4 h-4" />
                <span class="text-sm">{{ filter ? 'הסר סינון' : 'הצג רק לא נקראו' }}</span>
              </button>

              <button @click="markAllAsRead(); showActionsMenu = false"
                class="w-full px-4 py-2 text-right hover:bg-gray-50 flex items-center gap-3 text-green-700 transition-colors">
                <CheckCircleIcon class="w-4 h-4" />
                <span class="text-sm">סמן הכל כנקרא</span>
              </button>
            </div>
          </transition>
        </div>

        <!-- New Message Button -->
        <button
          class="w-10 h-10 rounded-full bg-indigo-600 text-white hover:bg-indigo-500 transition shadow-sm flex items-center justify-center"
          @click="newMessageDialogVisible = true" v-tippy="'שלח הודעה חדשה'">
          <MessageSquarePlus class="w-5 h-5" />
        </button>
      </div>
    </div>

    <!-- Google Status Info (if authenticated) -->
    <div v-if="googleStatus.isAuthenticated" class="bg-indigo-50 py-2 px-3 border-b border-indigo-100">
      <div class="flex justify-between text-xs">
        <a :href="`https://contacts.google.com/?authuser=${googleStatus.userEmail}`" target="_blank"
          class="font-semibold text-indigo-700">
          {{ googleStatus.userEmail }}
        </a>
        <span class="text-gray-600">
          {{ googleStatus.contactCount }} אנשי קשר
        </span>
      </div>
    </div>

    <!-- Search Bar -->
    <div class="px-4 py-3 top-16 bg-white bg-opacity-95 backdrop-blur-sm">
      <div
        class="relative flex items-center rounded-lg border border-gray-200 bg-gray-50 hover:bg-white focus-within:bg-white transition-all shadow-sm">
        <MagnifyingGlassIcon class="absolute right-3 w-4 h-4 text-gray-400" />
        <input type="text" placeholder="חפש בהודעות..."
          class="w-full py-2.5 pr-10 pl-4 text-sm rounded-lg focus:outline-none bg-transparent" v-model="searchQuery"
          dir="rtl" />
        <button v-if="searchQuery" @click="searchQuery = ''"
          class="absolute left-3 p-1 rounded-full hover:bg-gray-200 text-gray-400">
          <XMarkIcon class="w-3 h-3" />
        </button>
      </div>
    </div>

    <!-- Conversation List -->
    <div v-if="filteredConversations.length">
      <div v-for="conversation in filteredConversations" :key="conversation.id" @click="emit('select', conversation.id)"
        :class="[
          'p-4 hover:bg-gray-50 cursor-pointer transition-colors',
          String(conversation.id) === String(selectedId) ? 'bg-indigo-50 hover:bg-indigo-50 border-r-4 border-indigo-500' : ''
        ]">
        <div class="flex items-center space-x-3 space-x-reverse">
          <div class="relative">
            <img :src="conversation.avatar" alt=""
              class="h-12 w-12 rounded-full object-cover border border-gray-200 shadow-sm" />
            <div v-if="conversation.unreadCount > 0"
              class="absolute -top-1 -right-1 flex-shrink-0 w-5 h-5 bg-indigo-500 rounded-full flex items-center justify-center ring-2 ring-white">
              <span class="text-xs text-white font-medium">
                {{ conversation.unreadCount }}
              </span>
            </div>
          </div>

          <div class="flex-1 min-w-0">
            <div class="flex items-center justify-between">
              <p class="text-sm font-medium text-gray-900 truncate"
                :class="{ 'font-bold': conversation.unreadCount > 0 }">
                {{ conversation.name }}
              </p>
              <p class="text-xs text-gray-500 flex-shrink-0">
                {{ formatTime(conversation.lastMessage.timestamp) }}
              </p>
            </div>
            <p class="text-sm text-gray-500 truncate mt-0.5"
              :class="{ 'font-medium text-gray-700': conversation.unreadCount > 0 }">
              {{ conversation.lastMessage.content }}
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Empty State -->
    <div v-else-if="searchQuery && !filteredConversations.length"
      class="flex flex-col items-center justify-center h-64 text-gray-500">
      <MagnifyingGlassIcon class="w-10 h-10 text-gray-300 mb-2" />
      <p>לא נמצאו תוצאות ל-"{{ searchQuery }}"</p>
    </div>

    <div v-else-if="!props.conversations.length"
      class="flex-1 flex flex-col items-center justify-center text-gray-500 h-64">
      <svg class="animate-spin h-8 w-8 text-indigo-400 mb-3" xmlns="http://www.w3.org/2000/svg" fill="none"
        viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
        </path>
      </svg>
      טוען שיחות...
    </div>

  </div>

  <!-- New Message Dialog -->
  <NewMessageDialog :visible="newMessageDialogVisible" :should-focus="true" @success="handleNewMessageSuccess"
    @cancel="handleNewMessageCancel" @error="handleNewMessageError" />
</template>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.dropdown-enter-active,
.dropdown-leave-active {
  transition: all 0.15s ease-out;
}

.dropdown-enter-from {
  opacity: 0;
  transform: translateY(-4px) scale(0.95);
}

.dropdown-leave-to {
  opacity: 0;
  transform: translateY(-4px) scale(0.95);
}
</style>
</file>

<file path="src/App.vue">
<script setup>
import { ref, onMounted } from 'vue';
import MainView from './components/MessagesMainView.vue';
import LoginDialog from './components/LoginDialog.vue';
import PrivacyPolicy from './components/PrivacyPolicy.vue';
import { 
  hasValidCredentials, 
  getSavedCredentials, 
  clearCredentials,
  validateCredentials 
} from './services/encryption.service';

const loginDialogVisible = ref(false);
const username = ref('');
const isLoading = ref(true);

const openPrivacyPolicy = () => {
  window.openPrivacyPolicy();
};

const handleLoginSuccess = (loggedInUsername) => {
  username.value = loggedInUsername;
  loginDialogVisible.value = false;
  console.log('התחברות הצליחה עבור:', loggedInUsername);
};

const handleLoginError = (error) => {
  console.error('שגיאה בהתחברות:', error);
};

const logout = () => {
  clearCredentials();
  // נקה גם את הlocalStorage הישן
  localStorage.removeItem('username');
  localStorage.removeItem('password');
  
  username.value = '';
  loginDialogVisible.value = true;
  document.title = 'סמייל פרו - תצוגת שיחות';
  console.log('המשתמש התנתק מהמערכת');
};

const init = async () => {
  isLoading.value = true;
  
  try {
    // בדוק אם יש פרטי התחברות שמורים
    const hasCredentials = await hasValidCredentials();
    
    if (hasCredentials) {
      const credentials = await getSavedCredentials();
      if (credentials) {
        const isValid = await validateCredentials();
        
        if (isValid) {
          username.value = credentials.username;
          document.title = 'מערכת סמסים - ' + credentials.username;
        } else {
          clearCredentials();
          loginDialogVisible.value = true;
        }
      } else {
        loginDialogVisible.value = true;
      }
    } else {
      console.log('לא נמצאו פרטי התחברות שמורים');
      loginDialogVisible.value = true;
    }
  } catch (error) {
    console.error('שגיאה באתחול:', error);
    clearCredentials();
    loginDialogVisible.value = true;
  } finally {
    isLoading.value = false;
  }
};

// Request notification permissions
const requestNotificationPermissions = () => {
  if ('Notification' in window && Notification.requestPermission) {
    Notification.requestPermission().then((permission) => {
      if (permission === 'granted') {
        console.log('הרשאות התראות אושרו');
      } else {
        console.warn('הרשאות התראות נדחו');
      }
    });
  } else {
    console.warn('התראות לא נתמכות בדפדפן זה');
  }
};

onMounted(() => {
  init();
  requestNotificationPermissions();
});
</script>

<template>
  <div class="h-full">
    <!-- Loading Screen -->
    <div v-if="isLoading" class="fixed inset-0 bg-white flex justify-center items-center z-50">
      <div class="flex flex-col items-center">
        <svg class="animate-spin h-12 w-12 text-indigo-600 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none"
          viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
          </path>
        </svg>
        <p class="text-gray-600">טוען מערכת...</p>
      </div>
    </div>

    <!-- Main Application View -->
    <MainView 
      v-if="!isLoading && !loginDialogVisible && username" 
      :username="username" 
      @logout="logout" />

    <!-- Login Dialog -->
    <LoginDialog 
      :visible="loginDialogVisible && !isLoading"
      :should-focus="true"
      @login-success="handleLoginSuccess"
      @login-error="handleLoginError" />

    <!-- Privacy Policy -->
    <PrivacyPolicy />
  </div>
</template>

<style>
@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;600;700&display=swap');

html,
body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Heebo', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    "Helvetica Neue", Arial, sans-serif;
  direction: rtl;
  font-size: 16px;
}

#app {
  height: 100%;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
</file>

</files>
